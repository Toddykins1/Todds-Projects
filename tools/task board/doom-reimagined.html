<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 
    Doom Metal Task Board Application
    A dark, gloomy doom metal-inspired task management system with heavy shadows,
    metallic textures, and ominous animations.
  -->
  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>⚡ Doom Reimagined ⚡</title>
  
  <!-- Google Fonts: Metal Mania for heavy metal feel, and Creepster for horror text -->
  <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&family=Creepster&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    /* ========================================
       DOOM METAL DESIGN SYSTEM
       ======================================== */
    
    :root {
      /* === DOOM METAL COLOR PALETTE === */
      --bg: #0a0a0a;           /* Deep black background */
      --panel: #1a1a1a;        /* Dark gray panels */
      --panel-2: #111111;      /* Darker gray for depth */
      --ink: #cccccc;          /* Light gray text */
      --ink-dim: #888888;      /* Muted gray text */
      --line: #333333;         /* Dark borders */
      
      /* === DOOM METAL ACCENTS === */
      --metal: #4a3c5c;        /* Dark purple-gray */
      --rust: #6b4c7a;         /* Purple-brown */
      --blood: #8b008b;        /* Dark magenta */
      --steel: #7a5c8b;        /* Purple-steel */
      --bronze: #9b6b9b;       /* Purple-bronze */
      --iron: #3a2c4a;         /* Deep purple-gray */
      --copper: #8b6b9b;       /* Purple-copper */
      --silver: #b8a8c8;       /* Light purple-silver */
      
      /* === PRIORITY COLORS === */
      --critical: #ff0040;     /* Critical doom - bright red */
      --urgent: #ff4080;       /* Urgent doom - hot pink */
      --high: #8b008b;         /* High priority - dark magenta */
      --medium: #7a5c8b;       /* Medium priority - purple-steel */
      --low: #6b4c7a;          /* Low priority - purple-brown */
      --completed: #4a3c5c;    /* Completed - muted purple */
      
      /* === LAYOUT DIMENSIONS (REDUCED FOR 960px HEIGHT) === */
      --row-h: 36px;           /* Compact row height */
      --head-h: 42px;          /* Compact headers */
      
      /* === DOOM METAL EFFECTS === */
      --radius: 8px;           /* Sharp corners */
      --shadow: 0 4px 20px rgba(0,0,0,.8);  /* Heavy black shadow */
    }
    
    /* ========================================
       GLOBAL RESET & DOOM METAL BASE
       ======================================== */
    
    * {
      box-sizing: border-box;
    }
    
    html, body {
      height: 100%;
      max-height: 960px;
    }
    
    body {
      margin: 0;
      /* Doom metal dark background with purple haze */
      background: 
        radial-gradient(1200px 800px at 20% -10%, rgba(107,76,122,.12), transparent 50%),
        radial-gradient(1000px 600px at 80% 20%, rgba(122,92,139,.1), transparent 45%),
        radial-gradient(800px 500px at 50% 80%, rgba(74,60,92,.08), transparent 40%),
        radial-gradient(600px 400px at 30% 60%, rgba(139,0,139,.06), transparent 35%),
        linear-gradient(135deg, var(--bg) 0%, #0f0a15 50%, var(--bg) 100%);
      color: var(--ink);
      font-family: 'Orbitron', monospace;
      letter-spacing: .05em;
      line-height: 1.4;
      overflow-x: hidden;
    }
    
    /* Doom metal atmospheric overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 30%, rgba(107,76,122,.06) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(122,92,139,.04) 0%, transparent 50%),
        radial-gradient(circle at 50% 20%, rgba(74,60,92,.03) 0%, transparent 50%),
        radial-gradient(circle at 30% 80%, rgba(139,0,139,.03) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
      animation: doomAtmosphere 25s ease-in-out infinite;
    }
    
    @keyframes doomAtmosphere {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 1; }
      25% { transform: translateY(-5px) rotate(0.5deg); opacity: 0.8; }
      50% { transform: translateY(3px) rotate(-0.3deg); opacity: 0.9; }
      75% { transform: translateY(-3px) rotate(0.2deg); opacity: 0.7; }
    }
    
    /* ========================================
       DOOM METAL TOP BAR
       ======================================== */
    
    .topbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px 12px;
      border-bottom: 3px solid var(--metal);
      background: linear-gradient(135deg, var(--panel), var(--panel-2));
      position: relative;
      box-shadow: 0 2px 10px rgba(0,0,0,.5);
    }
    
    .topbar::before {
      content: '⚡ DOOM REIMAGINED ⚡';
      position: absolute;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      font-family: 'Metal Mania', cursive;
      font-size: 14px;
      color: var(--blood);
      text-shadow: 0 0 10px rgba(139,0,0,.8);
      animation: doomFlicker 3s ease-in-out infinite;
    }
    
    .doom-stats {
      position: absolute;
      top: 50%;
      right: 200px;
      transform: translateY(-50%);
      font-family: 'Orbitron', monospace;
      font-size: 11px;
      color: var(--ink-dim);
      display: flex;
      gap: 12px;
    }
    
    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .stat-value {
      font-weight: 700;
      color: var(--steel);
    }
    
    .stat-label {
      font-size: 9px;
      text-transform: uppercase;
      opacity: 0.7;
    }
    
    @keyframes doomFlicker {
      0%, 100% { opacity: 1; text-shadow: 0 0 10px rgba(139,0,0,.8); }
      50% { opacity: 0.7; text-shadow: 0 0 15px rgba(139,0,0,1); }
    }
    
    .topbar .label {
      color: var(--ink-dim);
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      font-weight: 600;
      opacity: .8;
      user-select: none;
      white-space: nowrap;
      text-transform: uppercase;
    }
    
    /* ========================================
       DOOM METAL INPUT COMPONENTS
       ======================================== */
    
    .task-input {
      width: 24ch;
      background: transparent;
      border: none;
      outline: none;
      color: var(--steel);
      caret-color: var(--steel);
      font: 600 15px 'Orbitron', monospace;
      padding: 8px 12px 6px;
      border-bottom: 2px solid transparent;
      transition: all .3s ease;
    }
    
    .task-input::placeholder {
      color: rgba(122,92,139,.6);
    }
    
    .task-input:focus {
      border-bottom-color: var(--steel);
      box-shadow: 0 2px 0 -1px rgba(122,92,139,.5);
      text-shadow: 0 0 5px rgba(122,92,139,.3);
    }
    
    .hint {
      font-size: 11px;
      color: var(--ink-dim);
      margin-left: 6px;
      font-family: 'Orbitron', monospace;
      text-transform: uppercase;
    }
    
    /* ========================================
       DOOM METAL BOARD LAYOUT
       ======================================== */
    
    .board {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto auto;
      gap: 16px;
      padding: 16px 20px 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .board .list-card:last-child {
      grid-column: 1/-1;
    }
    
    /* ========================================
       DOOM METAL LIST CARDS
       ======================================== */
    
    .list-card {
      /* Doom metal dark gradients with purple haze */
      background: 
        linear-gradient(135deg, rgba(107,76,122,.1), transparent 30%),
        linear-gradient(45deg, rgba(122,92,139,.08), transparent 25%),
        linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 2px solid var(--line);
      border-radius: var(--radius);
      box-shadow: 
        var(--shadow),
        inset 0 0 20px rgba(0,0,0,.3);
      padding: 12px 16px 16px;
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
      transition: all .3s ease;
    }
    
    .list-card:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 6px 25px rgba(0,0,0,.6),
        inset 0 0 20px rgba(0,0,0,.4);
    }
    
    .list-card::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--metal), var(--rust), var(--steel), var(--bronze));
      border-radius: var(--radius);
      z-index: -1;
      opacity: 0;
      transition: opacity .3s ease;
    }
    
    .list-card:hover::before {
      opacity: .2;
    }
    
    .list-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font: 700 16px 'Orbitron', monospace;
      letter-spacing: .05em;
      margin: 2px 6px 10px;
      color: var(--ink);
      position: relative;
      text-transform: uppercase;
    }
    
    .list-title .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--steel), var(--metal));
      box-shadow: 
        0 0 10px rgba(112,128,144,.6),
        0 0 20px rgba(112,128,144,.3);
      animation: doomPulse 3s ease-in-out infinite;
    }
    
    @keyframes doomPulse {
      0%, 100% { 
        transform: scale(1);
        box-shadow: 0 0 10px rgba(112,128,144,.6), 0 0 20px rgba(112,128,144,.3);
      }
      50% { 
        transform: scale(1.1);
        box-shadow: 0 0 15px rgba(112,128,144,.8), 0 0 30px rgba(112,128,144,.5);
      }
    }
    
    /* ========================================
       DOOM METAL TABLE CONTAINER
       ======================================== */
    
    .table-wrap {
      height: calc(var(--head-h) + var(--row-h) * 6);
      overflow: auto;
      border-radius: 8px;
      border: 2px solid var(--line);
      position: relative;
      background: 
        linear-gradient(180deg, rgba(26,26,26,.9), rgba(15,10,21,.8));
    }
    
    .table-wrap::-webkit-scrollbar {
      height: 8px;
      width: 8px;
    }
    
    .table-wrap::-webkit-scrollbar-thumb {
      background: linear-gradient(45deg, var(--metal), var(--rust), var(--steel), var(--bronze));
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,.5);
    }
    
    .table-wrap::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(45deg, var(--steel), var(--copper), var(--silver), var(--iron));
    }
    
    /* ========================================
       DOOM METAL TABLE STRUCTURE
       ======================================== */
    
    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      font-size: 14px;
    }
    
    thead th {
      position: sticky;
      top: 0;
      text-align: left;
      font-weight: 700;
      height: var(--head-h);
      padding: 8px 14px;
      background: linear-gradient(135deg, var(--panel), var(--panel-2));
      border-bottom: 2px solid var(--steel);
      z-index: 2;
      font-family: 'Orbitron', monospace;
      color: var(--ink);
      text-transform: uppercase;
      font-size: 12px;
    }
    
    tbody td {
      height: var(--row-h);
      padding: 6px 14px;
      vertical-align: middle;
      border-bottom: none;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
    
    /* ========================================
       DOOM METAL TASK ROWS
       ======================================== */
    
    .task-row {
      cursor: grab;
      transition: all .3s ease;
      position: relative;
    }
    
    .task-row:hover {
      background: rgba(122,92,139,.1);
      transform: translateX(4px);
    }
    
    .task-row:active {
      cursor: grabbing;
      transform: scale(1.02) rotate(0.5deg);
    }
    
    /* ========================================
       DOOM METAL TASK CHIPS
       ======================================== */
    
    .task-chip {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 4px;
      background: 
        linear-gradient(135deg, rgba(26,26,26,.9), rgba(15,10,21,.8));
      border: 1px solid var(--steel);
      color: var(--ink);
      font-weight: 500;
      letter-spacing: .05em;
      box-shadow: 
        0 2px 8px rgba(0,0,0,.5) inset,
        0 1px 4px rgba(0,0,0,.3);
      transition: all .3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .task-chip::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(122,92,139,.3), transparent);
      transition: left .5s ease;
    }
    
    .task-chip:hover::before {
      left: 100%;
    }
    
    .task-chip:hover {
      transform: translateY(-2px) rotate(0.5deg);
      box-shadow: 
        0 4px 12px rgba(0,0,0,.6) inset,
        0 2px 6px rgba(0,0,0,.4);
      border-color: var(--copper);
    }
    
    /* ========================================
       PRIORITY-BASED TASK STYLING
       ======================================== */
    
    .task-chip.priority-critical {
      border-color: var(--critical);
      box-shadow: 
        0 2px 8px rgba(255,0,64,.3) inset,
        0 0 10px rgba(255,0,64,.2);
      animation: criticalPulse 2s ease-in-out infinite;
    }
    
    .task-chip.priority-urgent {
      border-color: var(--urgent);
      box-shadow: 
        0 2px 8px rgba(255,64,128,.3) inset,
        0 0 8px rgba(255,64,128,.2);
    }
    
    .task-chip.priority-high {
      border-color: var(--high);
      box-shadow: 
        0 2px 8px rgba(139,0,139,.3) inset,
        0 0 6px rgba(139,0,139,.2);
    }
    
    .task-chip.priority-medium {
      border-color: var(--medium);
    }
    
    .task-chip.priority-low {
      border-color: var(--low);
      opacity: 0.8;
    }
    
    .task-chip.priority-completed {
      border-color: var(--completed);
      opacity: 0.6;
      text-decoration: line-through;
    }
    
    @keyframes criticalPulse {
      0%, 100% { 
        box-shadow: 0 2px 8px rgba(255,0,64,.3) inset, 0 0 10px rgba(255,0,64,.2);
      }
      50% { 
        box-shadow: 0 2px 12px rgba(255,0,64,.5) inset, 0 0 15px rgba(255,0,64,.4);
      }
    }
    
    /* ========================================
       DOOM METAL DRAG & DROP STATES
       ======================================== */
    
    .dragging {
      opacity: .6;
      filter: saturate(1.2) brightness(0.8);
      transform: rotate(2deg) scale(1.05);
    }
    
    .empty-row td {
      color: rgba(136,136,136,.2);
      border-bottom: none;
      position: relative;
    }
    
    .empty-row:hover td {
      background: rgba(122,92,139,.05);
    }
    
    .table-wrap.dropzone {
      border-color: var(--blood) !important;
      box-shadow: 
        0 0 20px rgba(139,0,139,.6),
        inset 0 0 15px rgba(0,0,0,.3);
      animation: doomGlow 1.5s ease-in-out infinite alternate;
    }
    
    @keyframes doomGlow {
      0% { 
        box-shadow: 0 0 20px rgba(139,0,139,.6), inset 0 0 15px rgba(0,0,0,.3);
      }
      100% { 
        box-shadow: 0 0 30px rgba(139,0,139,.8), inset 0 0 25px rgba(0,0,0,.5);
      }
    }
    
    /* ========================================
       DOOM METAL HEADER INPUT
       ======================================== */
    
    thead th .task-input {
      width: 100%;
      background: transparent;
      border: none;
      outline: none;
      color: var(--ink);
      font: 600 15px 'Orbitron', monospace;
      padding: 8px 14px;
      text-align: left;
      margin: 0;
      position: relative;
      z-index: 1;
    }
    
    thead th .task-input::placeholder {
      color: rgba(122,92,139,.6);
    }
    
    /* ========================================
       DOOM METAL TASK BANK LAYOUT
       ======================================== */
    
    .bank-columns {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0;
      padding: 0 8px 8px;
    }
    
    /* ========================================
       DOOM METAL TIMER ANIMATIONS
       ======================================== */
    
    .timer-done {
      color: var(--blood);
      animation: doomBlink 2s ease-in-out infinite;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(139,0,139,.8);
    }
    
    @keyframes doomBlink {
      0%, 100% { 
        opacity: 1;
        transform: scale(1);
        text-shadow: 0 0 8px rgba(139,0,139,.8);
      }
      50% { 
        opacity: 0.4;
        transform: scale(1.05);
        text-shadow: 0 0 12px rgba(139,0,139,1);
      }
    }
    
    /* ========================================
       DOOM METAL FLOATING ELEMENTS
       ======================================== */
    
    .floating-element {
      position: absolute;
      pointer-events: none;
      opacity: .1;
      animation: doomFloat 20s ease-in-out infinite;
    }
    
    @keyframes doomFloat {
      0% { transform: translate(0, 0) rotate(0deg); opacity: 0.1; }
      25% { transform: translate(40px, -30px) rotate(90deg); opacity: 0.05; }
      50% { transform: translate(30px, 40px) rotate(180deg); opacity: 0.08; }
      75% { transform: translate(-30px, 30px) rotate(270deg); opacity: 0.06; }
      100% { transform: translate(0, 0) rotate(360deg); opacity: 0.1; }
    }
    
    /* ========================================
       DOOM METAL RESPONSIVE DESIGN
       ======================================== */
    
    @media (max-width: 768px) {
      .board {
        grid-template-columns: 1fr;
        gap: 12px;
        padding: 12px 16px 16px;
      }
      
      .board .list-card:last-child {
        grid-column: 1;
      }
      
      .bank-columns {
        grid-template-columns: 1fr;
      }
      
      .topbar::before {
        display: none;
      }
      
      .doom-stats {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Doom metal floating elements -->
  <div class="floating-element" style="top: 8%; left: 6%; font-size: 32px;">⚡</div>
  <div class="floating-element" style="top: 18%; right: 8%; font-size: 28px;">🔥</div>
  <div class="floating-element" style="bottom: 20%; left: 10%; font-size: 24px;">💀</div>
  <div class="floating-element" style="top: 50%; right: 4%; font-size: 30px;">⚔️</div>
  <div class="floating-element" style="top: 30%; left: 2%; font-size: 26px;">🌑</div>
  <div class="floating-element" style="bottom: 35%; right: 12%; font-size: 22px;">⚡</div>
  
  <div class="topbar">
    <div class="label">Task Input</div>
    <input id="newTask" class="task-input" type="text" maxlength="120" placeholder="Add doom task..." autocomplete="off" />
    <div class="hint">Press Enter</div>
    
    <div class="doom-stats" id="doomStats">
      <div class="stat-item">
        <div class="stat-value" id="totalTasks">0</div>
        <div class="stat-label">Tasks</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="doomLevel">0</div>
        <div class="stat-label">Doom</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="timeSpent">0h</div>
        <div class="stat-label">Time</div>
      </div>
    </div>
  </div>
  
  <main class="board">
    
    <!-- ========================================
         DOOM METAL CURRENT FOCUS SECTION
         ======================================== -->
    <section class="list-card" data-list="now">
      <div class="list-title">
        <span class="dot"></span> 
        Current Doom
      </div>
      
      <div class="table-wrap">
        <table class="task-table">
          <thead>
            <tr>
              <th style="width:70px">⏰</th>
              <th>Doom Task</th>
            </tr>
          </thead>
          <tbody id="now-body">
            <!-- Task rows will be dynamically inserted here -->
          </tbody>
        </table>
      </div>
    </section>
    
    <!-- ========================================
         DOOM METAL NEEDS DOING SECTION
         ======================================== -->
    <section class="list-card" data-list="soon">
      <div class="list-title">
        <span class="dot"></span> 
        Upcoming Chaos
      </div>
      
      <div class="table-wrap">
        <table class="task-table">
          <thead>
            <tr>
              <th style="width:70px">Added</th>
              <th>Metal Task</th>
            </tr>
          </thead>
          <tbody id="soon-body">
            <!-- Task rows will be dynamically inserted here -->
          </tbody>
        </table>
      </div>
    </section>
    
    <!-- ========================================
         DOOM METAL TASK BANK SECTION
         ======================================== -->
    <section class="list-card" data-list="bank">
      <div class="list-title">
        <span class="dot"></span> 
        Doom Collection
      </div>
      
      <div class="table-wrap">
        <table class="task-table">
          <thead>
            <tr>
              <th colspan="3">
                <input 
                  id="newTask" 
                  class="task-input" 
                  type="text" 
                  maxlength="120" 
                  placeholder="Add doom task..." 
                  autocomplete="off" 
                />
              </th>
            </tr>
          </thead>
        </table>
        
        <div class="bank-columns">
          <table class="task-table">
            <tbody id="bank-col1-body">
              <!-- Column 1 tasks -->
            </tbody>
          </table>
          
          <table class="task-table">
            <tbody id="bank-col2-body">
              <!-- Column 2 tasks -->
            </tbody>
          </table>
          
          <table class="task-table">
            <tbody id="bank-col3-body">
              <!-- Column 3 tasks -->
            </tbody>
          </table>
        </div>
      </div>
    </section>
    
  </main>
  <script>
    /* ========================================
       DOM MANIPULATION UTILITIES
       ======================================== */
    
    const $ = id => document.getElementById(id);
    
    const el = (tag, attrs = {}, kids = []) => {
      const n = document.createElement(tag);
      
      for (const k in attrs) {
        if (k === 'style') {
          Object.assign(n.style, attrs.style);
        } else if (k === 'dataset') {
          Object.assign(n.dataset, attrs.dataset);
        } else {
          n[k] = attrs[k];
        }
      }
      
      kids.forEach(ch => n.appendChild(ch));
      return n;
    };
    
    const replace = (node, children) => node.replaceChildren(...children);

    /* ========================================
       ENHANCED DOOM METAL SYSTEM
       ======================================== */
    
    const PRIORITY_COLORS = {
      critical: '#ff0040',
      urgent: '#ff4080', 
      high: '#8b008b',
      medium: '#7a5c8b',
      low: '#6b4c7a',
      completed: '#4a3c5c'
    };
    
    const DOOM_KEYWORDS = {
      critical: ['urgent', 'asap', 'emergency', 'critical', 'deadline', 'now', 'immediate'],
      urgent: ['soon', 'today', 'important', 'priority', 'rush'],
      high: ['need', 'should', 'must', 'required'],
      medium: ['want', 'could', 'maybe', 'consider'],
      low: ['someday', 'later', 'eventually', 'optional']
    };
    
    const randomColor = () => Object.values(PRIORITY_COLORS)[Math.floor(Math.random() * Object.values(PRIORITY_COLORS).length)];
    
    // Enhanced task analysis function
    function analyzeTaskPriority(text) {
      const lowerText = text.toLowerCase();
      
      for (const [priority, keywords] of Object.entries(DOOM_KEYWORDS)) {
        if (keywords.some(keyword => lowerText.includes(keyword))) {
          return priority;
        }
      }
      
      // Default priority based on text length and complexity
      if (text.length > 50) return 'medium';
      if (text.length > 20) return 'high';
      return 'low';
    }
    
    // Enhanced task creation with metadata
    function createEnhancedTask(text) {
      const priority = analyzeTaskPriority(text);
      const createdAt = Date.now();
      const estimatedDuration = estimateTaskDuration(text);
      
      return {
        text: text.trim(),
        priority,
        createdAt,
        estimatedDuration,
        completedAt: null,
        timeSpent: 0,
        doomLevel: calculateDoomLevel(priority, createdAt)
      };
    }
    
    function estimateTaskDuration(text) {
      // Simple heuristic based on text length and keywords
      const words = text.split(' ').length;
      const complexKeywords = ['review', 'analyze', 'research', 'implement', 'design'];
      const hasComplex = complexKeywords.some(keyword => text.toLowerCase().includes(keyword));
      
      if (hasComplex) return Math.max(60, words * 5); // 5 minutes per word, minimum 1 hour
      return Math.max(15, words * 2); // 2 minutes per word, minimum 15 minutes
    }
    
    function calculateDoomLevel(priority, createdAt) {
      const age = Date.now() - createdAt;
      const ageHours = age / (1000 * 60 * 60);
      
      const priorityWeights = {
        critical: 4,
        urgent: 3,
        high: 2,
        medium: 1,
        low: 0
      };
      
      return Math.min(10, priorityWeights[priority] + Math.floor(ageHours / 24));
    }

    /* ========================================
       APPLICATION STATE
       ======================================== */
    
    const state = {
      tasks: {},
      lists: {
        now: [],
        soon: [],
        bank: []
      },
      stats: {
        totalTasks: 0,
        completedTasks: 0,
        averageDoomLevel: 0,
        totalTimeSpent: 0,
        lastUpdated: Date.now()
      },
      settings: {
        autoSortByPriority: true,
        showDoomLevel: true,
        enableSmartTimers: true
      }
    };
    
    const MIN_VISIBLE_ROWS = 6;

    /* ========================================
       DOM ELEMENT REFERENCES
       ======================================== */
    
    const els = {
      input: $('newTask'),
      bodies: {
        now: $('now-body'),
        soon: $('soon-body'),
        bankCol1: $('bank-col1-body'),
        bankCol2: $('bank-col2-body'),
        bankCol3: $('bank-col3-body')
      }
    };

    /* ========================================
       UTILITY FUNCTIONS
       ======================================== */
    
    const uid = () => 't' + Date.now().toString(36) + Math.random().toString(36).slice(2, 7);

    /* ========================================
       TASK MANAGEMENT FUNCTIONS
       ======================================== */
    
    function addTaskToBank(text) {
      const id = uid();
      const enhancedTask = createEnhancedTask(text);
      
      state.tasks[id] = enhancedTask;
      state.lists.bank.push(id);
      
      // Update statistics
      updateStats();
      
      // Auto-sort if enabled
      if (state.settings.autoSortByPriority) {
        sortTasksByPriority();
      }
      
      renderAll();
    }
    
    function updateStats() {
      const tasks = Object.values(state.tasks);
      state.stats.totalTasks = tasks.length;
      state.stats.completedTasks = tasks.filter(t => t.completedAt).length;
      state.stats.averageDoomLevel = tasks.reduce((sum, t) => sum + t.doomLevel, 0) / tasks.length || 0;
      state.stats.totalTimeSpent = tasks.reduce((sum, t) => sum + t.timeSpent, 0);
      state.stats.lastUpdated = Date.now();
      
      // Update UI
      updateStatsDisplay();
    }
    
    function updateStatsDisplay() {
      const totalTasksEl = $('totalTasks');
      const doomLevelEl = $('doomLevel');
      const timeSpentEl = $('timeSpent');
      
      if (totalTasksEl) totalTasksEl.textContent = state.stats.totalTasks;
      if (doomLevelEl) doomLevelEl.textContent = Math.round(state.stats.averageDoomLevel * 10) / 10;
      if (timeSpentEl) timeSpentEl.textContent = Math.round(state.stats.totalTimeSpent / 60) + 'h';
    }
    
    function sortTasksByPriority() {
      const priorityOrder = { critical: 0, urgent: 1, high: 2, medium: 3, low: 4, completed: 5 };
      
      Object.keys(state.lists).forEach(listKey => {
        state.lists[listKey].sort((a, b) => {
          const taskA = state.tasks[a];
          const taskB = state.tasks[b];
          if (!taskA || !taskB) return 0;
          
          const priorityDiff = priorityOrder[taskA.priority] - priorityOrder[taskB.priority];
          if (priorityDiff !== 0) return priorityDiff;
          
          // Secondary sort by doom level (higher doom = higher priority)
          return taskB.doomLevel - taskA.doomLevel;
        });
      });
    }

    const chipFor = id => {
      const t = state.tasks[id];
      
      if (!t) {
        console.warn(`Task with id ${id} not found in state.tasks`);
        return el('span', {
          className: 'task-chip priority-low',
          textContent: '[Doom lost...]'
        });
      }
      
      const s = el('span', { 
        className: `task-chip priority-${t.priority}`,
        title: `Priority: ${t.priority} | Doom Level: ${t.doomLevel}/10 | Est: ${Math.round(t.estimatedDuration)}min`
      });
      
      // Create enhanced task display
      const taskText = el('span', { textContent: t.text });
      s.appendChild(taskText);
      
      // Add doom level indicator if enabled
      if (state.settings.showDoomLevel && t.doomLevel > 0) {
        const doomIndicator = el('span', {
          className: 'doom-indicator',
          textContent: ` [${t.doomLevel}]`,
          style: {
            fontSize: '0.8em',
            opacity: '0.7',
            color: t.doomLevel > 7 ? '#ff0040' : t.doomLevel > 4 ? '#ff4080' : '#8b008b'
          }
        });
        s.appendChild(doomIndicator);
      }
      
      return s;
    };

    /* ========================================
       TIME FORMATTING UTILITIES
       ======================================== */
    
    const sameDay = (a, b) => 
      a.getFullYear() === b.getFullYear() &&
      a.getMonth() === b.getMonth() &&
      a.getDate() === b.getDate();
    
    const formatSoon = ms => {
      const d = new Date(ms);
      const now = new Date();
      
      return sameDay(d, now) 
        ? d.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })
        : d.toLocaleDateString([], { month: 'short', day: 'numeric' });
    };

    /* ========================================
       RENDERING SYSTEM
       ======================================== */
    
    function renderAll() {
      renderList('now');
      renderList('soon');
      renderBank();
    }

    function renderList(listId) {
      const body = els.bodies[listId];
      const ids = state.lists[listId];
      
      const rows = ids.map((id, index) => {
        if (!state.tasks[id]) {
          console.warn(`Task with id ${id} not found in state.tasks`);
          return null;
        }
        
        const tdA = el('td');
        
        if (listId === 'soon') {
          const ts = state.tasks[id].addedSoonAt;
          tdA.textContent = ts ? formatSoon(ts) : '—';
        }
        
        if (listId === 'now') {
          const task = state.tasks[id];
          const end = task.nowEndAt;
          if (end) {
            const rem = end - Date.now();
            if (rem <= 0) {
              tdA.textContent = '⚡';
              tdA.classList.add('timer-done');
              tdA.title = 'Doom timer expired!';
            } else {
              const timeText = formatMMSS(rem);
              const progress = Math.round((1 - rem / (task.estimatedDuration * 60 * 1000)) * 100);
              tdA.textContent = timeText;
              tdA.title = `Progress: ${progress}% | Est: ${task.estimatedDuration}min | Doom: ${task.doomLevel}/10`;
              tdA.classList.remove('timer-done');
              
              // Add visual progress indicator
              if (progress > 80) {
                tdA.style.color = '#ff0040';
                tdA.style.textShadow = '0 0 5px rgba(255,0,64,.5)';
              } else if (progress > 60) {
                tdA.style.color = '#ff4080';
                tdA.style.textShadow = '0 0 3px rgba(255,64,128,.3)';
              }
            }
          } else {
            tdA.textContent = '';
          }
        }
        
        const tr = el('tr', {
          className: 'task-row',
          draggable: true,
          dataset: { taskId: id, listId, index }
        }, [
          tdA,
          el('td', {}, [chipFor(id)])
        ]);
        
        attachRowDnD(tr);
        return tr;
      }).filter(row => row !== null);
      
      const placeholders = Math.max(MIN_VISIBLE_ROWS - ids.length, 0);
      for (let i = 0; i < placeholders; i++) {
        const ph = el('tr', {
          className: 'empty-row',
          dataset: { listId }
        }, [el('td'), el('td')]);
        attachDropToRow(ph);
        rows.push(ph);
      }
      
      attachDropToTbody(body);
      replace(body, rows);
    }

    function renderBank() {
      const ids = state.lists.bank;
      const columns = [[], [], []];
      
      ids.forEach((id, i) => columns[i % 3].push(id));
      
      const paint = (bodyEl, colIds, colIndex) => {
        const nodes = colIds.map((id, i) => {
          const index = colIndex + i * 3;
          
          const tr = el('tr', {
            className: 'task-row',
            draggable: true,
            dataset: { taskId: id, listId: 'bank', index }
          }, [
            el('td', {}, [chipFor(id)])
          ]);
          
          attachRowDnD(tr);
          return tr;
        });
        
        const placeholders = Math.max(MIN_VISIBLE_ROWS - colIds.length, 0);
        for (let i = 0; i < placeholders; i++) {
          const ph = el('tr', {
            className: 'empty-row',
            dataset: { listId: 'bank' }
          }, [el('td')]);
          attachDropToRow(ph);
          nodes.push(ph);
        }
        
        attachDropToTbody(bodyEl);
        replace(bodyEl, nodes);
      };
      
      paint(els.bodies.bankCol1, columns[0], 0);
      paint(els.bodies.bankCol2, columns[1], 1);
      paint(els.bodies.bankCol3, columns[2], 2);
    }

    /* ========================================
       DRAG & DROP SYSTEM
       ======================================== */
    
    let dragData = null;
    
    const getList = id => 
      id ? (id.startsWith('bank-') ? 'bank' : id.replace('-body', '')) : null;
    
    function bankDropIndexFromRow(tr) {
      const tbodyId = tr.closest('tbody').id;
      const colMatch = tbodyId.match(/bank-col(\d+)-body/);
      
      if (!colMatch) return 0;
      
      const colIndex = parseInt(colMatch[1]) - 1;
      let realIndex = 0;
      
      for (const c of tr.parentElement.children) {
        if (c === tr) break;
        if (c.classList.contains('task-row')) realIndex++;
      }
      
      return colIndex + realIndex * 3;
    }
    
    const clearDnD = () => {
      document.querySelectorAll('.table-wrap').forEach(tw => 
        tw.classList.remove('dropzone')
      );
      document.querySelectorAll('tr.drop-before').forEach(el => 
        el.classList.remove('drop-before')
      );
    };

    function attachRowDnD(tr) {
      tr.addEventListener('dragstart', e => {
        const { taskId, listId, index } = tr.dataset;
        dragData = { taskId, fromList: listId, fromIndex: Number(index) };
        tr.classList.add('dragging');
        e.dataTransfer.setData('text/plain', taskId);
        e.dataTransfer.effectAllowed = 'move';
      });
      
      tr.addEventListener('dragend', () => {
        tr.classList.remove('dragging');
        clearDnD();
        dragData = null;
      });
      
      tr.addEventListener('dragover', e => {
        if (!dragData) return;
        e.preventDefault();
        tr.closest('.table-wrap').classList.add('dropzone');
        document.querySelectorAll('tr.drop-before').forEach(el => 
          el.classList.remove('drop-before')
        );
        tr.classList.add('drop-before');
      });
      
      tr.addEventListener('dragleave', () => tr.classList.remove('drop-before'));
      
      tr.addEventListener('drop', e => {
        e.preventDefault();
        if (!dragData) return;
        
        const tbody = tr.closest('tbody');
        const toList = getList(tbody.id);
        const beforeIndex = (toList === 'bank') 
          ? bankDropIndexFromRow(tr) 
          : Array.from(tr.parentElement.children).indexOf(tr);
        
        moveTask(dragData.taskId, dragData.fromList, toList, beforeIndex);
        dragData = null;
      });
    }

    function attachDropToRow(tr) {
      tr.addEventListener('dragover', e => {
        if (!dragData) return;
        e.preventDefault();
        tr.closest('.table-wrap').classList.add('dropzone');
        tr.classList.add('drop-before');
      });
      
      tr.addEventListener('dragleave', () => tr.classList.remove('drop-before'));
      
      tr.addEventListener('drop', e => {
        e.preventDefault();
        if (!dragData) return;
        
        const toList = getList(tr.closest('tbody').id);
        moveTask(dragData.taskId, dragData.fromList, toList, Infinity);
        dragData = null;
      });
    }

    function attachDropToTbody(tbody) {
      if (tbody.dataset.bound === '1') return;
      tbody.dataset.bound = '1';
      
      tbody.addEventListener('dragover', e => {
        if (!dragData) return;
        e.preventDefault();
        tbody.closest('.table-wrap').classList.add('dropzone');
      });
      
      tbody.addEventListener('dragleave', () => 
        tbody.closest('.table-wrap').classList.remove('dropzone')
      );
      
      tbody.addEventListener('drop', e => {
        e.preventDefault();
        if (!dragData) return;
        
        const toList = getList(e.currentTarget.id);
        moveTask(dragData.taskId, dragData.fromList, toList, Infinity);
        dragData = null;
      });
    }

    function moveTask(taskId, fromList, toList, beforeIndex) {
      clearDnD();
      if (!taskId || !fromList || !toList) return;
      
      if (!state.tasks[taskId]) {
        console.warn(`Cannot move task with id ${taskId} - task not found in state.tasks`);
        return;
      }
      
      const fromArr = state.lists[fromList];
      const i = fromArr.indexOf(taskId);
      if (i > -1) fromArr.splice(i, 1);
      
      const toArr = state.lists[toList];
      
      if (toList === 'soon' && !state.tasks[taskId].addedSoonAt) {
        state.tasks[taskId].addedSoonAt = Date.now();
      }
      
      if (toList === 'now') {
        const task = state.tasks[taskId];
        const duration = state.settings.enableSmartTimers ? 
          task.estimatedDuration * 60 * 1000 : 
          30 * 60 * 1000; // Default 30 minutes
        
        task.nowEndAt = Date.now() + duration;
        task.startedAt = Date.now();
        ensureNowInterval();
      }
      
      const dest = Number.isFinite(beforeIndex) 
        ? Math.min(Math.max(0, beforeIndex), toArr.length) 
        : toArr.length;
      
      if (!toArr.includes(taskId)) {
        toArr.splice(dest, 0, taskId);
      }
      
      renderAll();
    }

    /* ========================================
       TIMER SYSTEM FOR "NOW" TASKS
       ======================================== */
    
    let nowInterval = null;
    
    function ensureNowInterval() {
      if (!nowInterval) {
        nowInterval = setInterval(() => {
          if (state.lists.now.length) {
            renderList('now');
          } else {
            clearInterval(nowInterval);
            nowInterval = null;
          }
        }, 1000);
      }
    }
    
    function clearNowInterval() {
      if (nowInterval) {
        clearInterval(nowInterval);
        nowInterval = null;
      }
    }
    
    window.addEventListener('beforeunload', clearNowInterval);
    
    const pad = n => String(n).padStart(2, '0');
    
    function formatMMSS(ms) {
      const sec = Math.ceil(ms / 1000);
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${pad(m)}:${pad(s)}`;
    }

    /* ========================================
       INPUT HANDLING
       ======================================== */
    
    els.input.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        const v = els.input.value.trim();
        if (v) {
          addTaskToBank(v);
          els.input.value = '';
        }
      }
    });

    /* ========================================
       APPLICATION INITIALIZATION
       ======================================== */
    
    function init() {
      updateStats();
      renderAll();
    }
    
    // Enhanced task completion handler
    function completeTask(taskId) {
      const task = state.tasks[taskId];
      if (task && !task.completedAt) {
        task.completedAt = Date.now();
        task.priority = 'completed';
        
        // Calculate time spent if task was in 'now' list
        if (task.startedAt) {
          task.timeSpent += Date.now() - task.startedAt;
        }
        
        updateStats();
        renderAll();
      }
    }
    
    // Add double-click to complete task
    document.addEventListener('dblclick', (e) => {
      const taskRow = e.target.closest('.task-row');
      if (taskRow && taskRow.dataset.taskId) {
        completeTask(taskRow.dataset.taskId);
      }
    });
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
    
  </script>
</body>
</html>
